do {
    let coroutine_running = coroutine.running;
    let coroutine_resume  = coroutine.resume;
    let coroutine_yield   = coroutine.yield;

    let fn Error(err) {
        MsgC(Color(137, 222, 255), "[ERROR] ", err, "\n");
    }

    let AWAIT_FAILED = {
        __tostring: (s) => {
            "await error: " .. tostring(s.err)
        }
    };

    let await_failed_index = {
        __index: AWAIT_FAILED
    };

    fn Lau.__AWAIT__(promise) {
        let co = coroutine_running();
        if !co {
            error("await can only be used in async functions", 2);
        }

        if !Promise:is_promise(promise) {
            promise = Promise.resolve(promise);
        }

        promise:next(val => {
            let status, err = coroutine_resume(co, val);
            if status == false {
                Error(err);
            }
        }, err => {
            let status, err = coroutine_resume(co, setmetatable({err: err}, await_failed_index));
            if status == false {
                Error(err);
            }
        });

        return coroutine_yield();
    }

    let getmetatable = getmetatable;
    fn Lau.await_failed(tbl) {
        getmetatable(tbl) == await_failed_index
    }
}