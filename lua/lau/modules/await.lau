do {
    use coroutine.{running, resume, yield};

    let fn resolve(co, value) {
        let status, err = resume(co, value);
        if status == false {
            error(err);
        }
    }

    let fn promise_resolve(self, value) {
        resolve(self.co, value);
    }

    let fn promise_reject(self, err) {
        resolve(self.co, setmetatable({err: err}, await_failed_index));
    }

    fn Lau.__AWAIT__(promise) {
        let co = running();
        if !co {
            error("await can only be used in async functions", 2);
        }

        if !Promise:is_promise(promise) {
            promise = Promise.resolve(promise);
        }

        let state = promise.state;
        if state != "Pending" {
            if state == "Fulfilled" {
                return promise.value;
            } else {
                return setmetatable({err: promise.value}, await_failed_index);
            }
        }

        promise.co = co;
        promise.resolve = promise_resolve;
        promise.reject  = promise_reject;

        return yield();
    }

    let getmetatable = getmetatable;
    fn Lau.await_failed(tbl) {
        getmetatable(tbl) == await_failed_index
    }
}