let pcall = pcall;
let isfunction = isfunction;
let setmetatable = setmetatable;
let getmetatable = getmetatable;
let timer_simple = timer.Simple;

let PENDING = {};
let RESOLVED = {};
let REJECTED = {};

Promise = {};
Promise.__index = Promise;
function Promise:__new(callback) {
    let promise = {
        __state: PENDING,
        __handlers: {}
    };
    setmetatable(promise, self);
    if (!isfunction(callback))
        error("invalid function passed to the Promise", 2);
    let safe, args = pcall(() => {
        callback(
            res => {promise:__resolve(res);},
            err => {promise:__reject(err);}
        );
    });
    if (safe == false)
        promise:__reject(args);
    return promise;
}
function Promise:__tostring() {
    if (self.__state == PENDING)
        return "Promise: pending";
    else if (self.__state == RESOLVED)
        return "Promise: fulfilled (" .. self.__value .. ")";
    else
        return "Promise: rejected (" .. self.__value .. ")";
}
function Promise:__resolve(res) {
    if (self.__state != PENDING)
        return;
    let safe, args = pcall(() => {
        if (Promise.isPromise(res))
            res:then(
                rs => {self:__resolve(rs);},
                er => {self:__reject(er);}
            );
        else {
            self.__state = RESOLVED;
            self.__value = res;
            for (i, handler in ipairs(self.__handlers))
                handler.onresolve(res);
        }
    });
    if (safe == false)
        self:__reject(args);
}
function Promise:__reject(err) {
    if (self.__state != PENDING)
        return;
    self.__value = err;
    self.__state = REJECTED;
    for (i, handler in ipairs(self.__handlers))
        handler.onreject(err);
}
function Promise:done(onres = (() => {}), onrej = (() => {})) {
    timer_simple(0, () => {
        if (self.__state == PENDING)
            table.insert(self.__handlers, {
                onresolve: onres,
                onreject: onrej
            });
        else if (self.__state == RESOLVED)
            onres(self.__value);
        else
            onrej(self.__value);
    });
}
function Promise:then(onres, onrej) {
    return new Promise((res, rej) => {
        self:done(rs => {
            if (isfunction(onres)) {
                let safe, args = pcall(() => {
                    res(onres(rs));
                });
                if (safe == false)
                    rej(args);
            } else
                resolve(res);
        }, err => {
            if (isfunction(onrej)) {
                let safe, args = pcall(() => {
                    res(onrej(err));
                });
                if (safe == false)
                    rej(args);
            } else 
                rej(err);
        });
    });
}
function Promise:catch(onrej) {
    return self.then(self, nil, onreject);
}
function Promise.resolve(v) {
    return new Promise(res => {
        res(v);
    });
}
function Promise.reject(v) {
    return new Promise((_, rej) => {
        rej(v);
    });
}
function Promise.all(promises) {
    return new Promise((res, rej) => {
        let count = table.maxn(promises);
        if (count == 0)
            res({});
        let results = {};
        for (i = 1, count) {
            let promise = promises[i];
            if (!Promise.isPromise(promise))
                promise = Promise.resolve(promise);
            promise:done(result => {
                results[i] = result;
                if (--count == 0)
                    res(results);
            }, err => {
                rej({
                    id: i,
                    err: err
                });
            });
        }
    });
}
Promise.isPending   = s => s.__state == PENDING;
Promise.isRejected  = s => s.__state == REJECTED;
Promise.isResolved  = s => s.__state == RESOLVED;
Promise.isSettled   = s => !s.isPending(s);
Promise.isFulfilled = s => s.isResolved(s);
Promise.isPromise   = s => getmetatable(s) == Promise;
/*
    cool shit
*/
let http_fetch = http.Fetch;
let http_post = http.Post;
Promise.http = {};
Promise.http.Fetch = (url, headers) => new Promise(
    (res, rej) => {http_fetch(url, res, rej, headers);}
);
Promise.http.Post = (url, parameters, headers) => new Promise(
    (res, rej) => {http_post(url, parameters, res, rej, headers);}
);
Promise.Sleep = t => new Promise(res => {
    t = tonumber(t);
    assert(isnumber(t), "delay needs to be a number!");
    timer_simple(t, () => {
        res(t);
    });
});